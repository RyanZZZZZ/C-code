#include<windows.h>
#include<stdio.h>
#include<stdlib.h>
unsigned char *pbibuf;
unsigned char *pbibufcpy;
int biWidth;
int biHeight;
int biBitCount;
int biSizeImage;
int biXPelsPerMeter;
int biYPelsPerMeter;
int biClrUsed;
int biClrImportant;
int biCompression;
int biPlanes;
unsigned short int  bfType;
unsigned long       bfSize;
unsigned short int  bfReserved1;
unsigned short int  bfReserved2;
unsigned long       bfOffBits;
RGBQUAD *pclb;

/*typedef struct bit{
unsigned char a : 4;
}bi, *pbi;//定义类型：4位位域以及指向位域结构体指针
int All_Bcpy;
char c[50000];//存储像素信息，因为编译器不支持变长数组，所以暂定数组长度，下同*/

int bmp_read()
{
	FILE *fp = fopen("test.bmp", "rb");
	if (fp == 0)
		return 0;
	BITMAPFILEHEADER filehead;
	fread(&filehead, sizeof(BITMAPFILEHEADER), 1, fp);
	bfSize = filehead.bfSize;
	bfReserved1 = filehead.bfReserved1;
	bfReserved2 = filehead.bfReserved2;
	bfOffBits = filehead.bfOffBits;
	fseek(fp, sizeof(BITMAPFILEHEADER), 0);

	BITMAPINFOHEADER bitmapinfoheader;
	fread(&bitmapinfoheader, sizeof(BITMAPINFOHEADER), 1, fp);

	biWidth = bitmapinfoheader.biWidth;
	biHeight = bitmapinfoheader.biHeight;
	biBitCount = bitmapinfoheader.biBitCount;
	biSizeImage = bitmapinfoheader.biSizeImage;
	biXPelsPerMeter = bitmapinfoheader.biXPelsPerMeter;
	biYPelsPerMeter = bitmapinfoheader.biYPelsPerMeter;

	int row_B = (biWidth * biBitCount / 8 + 3) / 4 * 4;
	int All_B = row_B * biHeight;
	if (biBitCount == 24)
	{
		pbibuf = new unsigned char[All_B * (biBitCount / 8)];
		pbibufcpy = new unsigned char[All_B * (biBitCount / 8)];
		fread(pbibuf, 1, All_B, fp);
	}
	else if (biBitCount == 8)
	{
		pclb = (RGBQUAD *)malloc(sizeof(RGBQUAD[256]));
		fread(pclb, sizeof(RGBQUAD), 256, fp);
		pbibuf = new unsigned char[All_B * (biBitCount / 8)];
		pbibufcpy = new unsigned char[All_B * (biBitCount / 8)];
		fread(pbibuf, 1, All_B, fp);
	}
	else if (biBitCount == 16)
	{
		pclb = (RGBQUAD *)malloc(sizeof(RGBQUAD[65536]));
		fread(pclb, sizeof(RGBQUAD), 65536, fp);
		pbibuf = new unsigned char[All_B * (biBitCount / 8)];
		pbibufcpy = new unsigned char[All_B * (biBitCount / 8)];
		fread(pbibuf, 1, All_B, fp);
	}
	/*4位位图处理未能成功，采取了两种方法尝试解决：
	1、将颜色信息以每一字节为单位进行转换(效果等同于处理8位位图，只是颜色板和申请的内存大小发生了变化），运行后程序崩溃，图像被转换成了由竖直的，只有红蓝通道颜色的像素组成的交叉式颜色带；
	（1）经调试发现，问题出在文件写入上，文件写入操作中出现了访问冲突导致无法进行文件关闭操作，程序崩溃，由此可见并不能以一字节为单位进行转换，其中必定有由单位大小引发的内存地址访问冲突问题；
	（2）观察到上述4位位图的长宽与位图大小没有理论上的关系，宽度增加了2位之后算出来才是实际位图大小，可能是在位数转换时图片大小出现了改变，这可能与文件信息排列方式有某种关联。现因资源有限，无法找到天然的4位位图进行进一步实验。

	2、定义结构体类型bit，将指针移动单位（或数组元素储存大小）细化为4位并将像素数据强制类型转换为以4位为单位的数据（因为在理论上循环中指针以0.5个字节移动），程序运行完成后图像文件损坏，故未能实现。

	综上所述：作对称变换，在像素数据交换时判断条件中必然会涉及到长宽数据（转置则不需要），而由上面的数据采集结果只能得出理论宽度，与实际宽度有差别，且在转换过程中可能存在某些我的知识范围外的不可预测的变化, 因此4位位图的对称变换处理不了了之；
	在第二点的方法上具有很强的可操作性，由于个人能力有限，未能实现，甚是遗憾。

	else if (biBitCount == 4)
	{
	pclb = (RGBQUAD *)malloc(sizeof(RGBQUAD[16]));
	fread(pclb, sizeof(RGBQUAD), 16, fp);
	pbibuf = new unsigned char[All_B];
	pbibufcpy = new unsigned char[All_B];
	fread(c, 1, All_B, fp);
	}*/
	else if (biBitCount == 32)
	{
		pclb = (RGBQUAD *)malloc(sizeof(RGBQUAD[65536]));
		fread(pclb, sizeof(RGBQUAD), 65536, fp);
		pbibuf = new unsigned char[All_B * (biBitCount / 8)];
		pbibufcpy = new unsigned char[All_B * (biBitCount / 8)];
		fread(pbibuf, 1, All_B, fp);
	}
	fclose(fp);
	return 0;
}

int bmp_flush(unsigned char*buf, int width, int height, int biBitCount, RGBQUAD *pclb, int xp, int yp, int c_u, int c_im, int c_com)
{
	if (!buf)
		return 0;
	int clsize = 0;
	if (biBitCount < 24)
		clsize = 1024;

	int row_B = (width * biBitCount / 8 + 3) / 4 * 4;
	FILE *fp = fopen("test.bmp", "wb");
	if (fp == 0)
		return 0;
	BITMAPFILEHEADER fileHead;
	fileHead.bfType = 0x4D42;
	fileHead.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + clsize + row_B * height;
	fileHead.bfReserved1 = 0;
	fileHead.bfReserved2 = 0;
	fileHead.bfOffBits = 54 + clsize;
	fwrite(&fileHead, sizeof(BITMAPFILEHEADER), 1, fp);

	BITMAPINFOHEADER bitmapinfoheader;
	bitmapinfoheader.biBitCount = biBitCount;
	bitmapinfoheader.biClrImportant = c_im;
	bitmapinfoheader.biClrUsed = c_u;
	bitmapinfoheader.biCompression = c_com;
	bitmapinfoheader.biHeight = height;
	bitmapinfoheader.biPlanes = 1;
	bitmapinfoheader.biSize = 40;
	bitmapinfoheader.biSizeImage = row_B * height;
	bitmapinfoheader.biWidth = width;
	bitmapinfoheader.biXPelsPerMeter = xp;
	bitmapinfoheader.biYPelsPerMeter = yp;

	fwrite(&bitmapinfoheader, sizeof(BITMAPINFOHEADER), 1, fp);

	if (biBitCount == 8)
		fwrite(pclb, sizeof(RGBQUAD), 256, fp);

	fwrite(buf, height*row_B, 1, fp);
	fclose(fp);
	return 0;
}

int main()
{
	bmp_read();
	int i, j;
	int row_B = (biWidth*biBitCount / 8 + 3) / 4 * 4;
	int k;
	printf("该程序支持8位及以上位图的左右对称变换\n位图各项数据如下：\n1.文件大小为%lu\n2.保留字1为%u\n3.保留字2为%u\n4.偏移量为%lu\n5.位图大小为%d\n6.位图水平分辨率为%d\n7.位图垂直分辨率为%d\n8.位图宽度为%d\n9.位图高度为%d\n10.颜色深度为%d\n11.位图实际使用颜色数为%d\n12.位图显示中比较重要颜色数为%d\n13.位图压缩类型为%d\n14.目标设备位图数为1\n\n", bfSize, bfReserved1, bfReserved2, bfOffBits, row_B * biHeight, biXPelsPerMeter, biYPelsPerMeter, biWidth, biHeight, biBitCount, biClrUsed, biClrImportant, biCompression, biPlanes);
	printf("现在，请您打开 test.bmp 来查看图像变化\n\n");                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  //真彩图在生成时如果没有人为写入位图大小（biSizeImage)，则默认置为0
	if (biBitCount == 4)
	{
		/*pbi p = (pbi)malloc(sizeof(bi) * All_Bcpy);
		//pbi p1 = p;
		bi ar[50000];//声明位域结构数组
		int i = 0, j = 0;

		while (i++ < All_Bcpy)
		{
		(p++)->a = c[i];
		}

		unsigned char a[50000];
		while (j++ < All_Bcpy) { a[j] = c[j]; }
		for(int i = 1; i < All_Bcpy; i += 2)
		{
		ar[i].a = a[i];
		}

		for(int k = 0; k< All_Bcpy; k += 2)
		{
		ar[k].a = a[k] >> 4;
		}

		unsigned char press[50000], presscpy[50000];//压缩数据装入数组和其副本中

		int m = 0, n = 0;
		while (m++ < All_Bcpy && n < All_Bcpy / 2) { press[m] = ar[(n++) * 2 + 1].a | ar[(n++) * 2].a << 4; }//得到8位大小的数据
		//开始像素转换，这里仍旧采用8位8位变换
		for (i = 0; i<biHeight; i++)
		for (j = 0; j<(biWidth + 2) / 2; j++)
		press[i * row_B + j] = press[i * row_B + ((biWidth + 2) - j - 1)];

		for (i = 0; i<biHeight; i++)
		for (j = (biWidth + 2) / 2; j >= ((biWidth + 2) / 2) && (j<(biWidth + 2)); j++)
		press[i * row_B + j] = presscpy[i * row_B + ((biWidth + 2) - 1 - j)];

		bmp_flush(press, biWidth, biHeight, biBitCount, pclb);*/
	}
	else
	{
		for (i = 0; i < biHeight; i++)
			for (j = 0; j <= (biWidth - 1) / 2 * (biBitCount / 8); j += biBitCount / 8)
				for (k = 0; k < biBitCount / 8; k++)
					*(pbibufcpy + i * row_B + j + k) = *(pbibuf + i * row_B + j + k);

		for (i = 0; i < biHeight; i++)
			for (j = 0; j <= (biWidth - 1) / 2 * (biBitCount / 8); j += biBitCount / 8)
				for (k = 0; k < biBitCount / 8; k++)
					*(pbibuf + i * row_B + j + k) = *(pbibuf + i * row_B + biWidth * (biBitCount / 8) - (biBitCount / 8) - j + k);

		for (i = 0; i < biHeight; i++)
			for (j = biWidth / 2 * (biBitCount / 8); j >= (biWidth / 2 * (biBitCount / 8)) && j < (biWidth * (biBitCount / 8)); j += biBitCount / 8)
				for (k = 0; k < biBitCount / 8; k++)
					*(pbibuf + i * row_B + j + k) = *(pbibufcpy + i * row_B + biWidth * (biBitCount / 8) - (biBitCount / 8) - j + k);

		bmp_flush(pbibuf, biWidth, biHeight, biBitCount, pclb, biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant, biCompression);
	}
	delete[]pbibuf;
	free(pclb);
	return 0;
}
